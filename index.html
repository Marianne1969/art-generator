
<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎨 מחולל יצירות אמנות - Base44</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Assistant:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Assistant', sans-serif;
        }
        
        .color-strip {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .color-strip:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .canvas-container {
            background: #f9fafb;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #6366f1;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .floating {
            animation: float 3s ease-in-out infinite;
        }
        
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .glass-effect {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .selected-item {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            z-index: 1000;
        }
        
        .status-connected {
            background: #10b981;
            color: white;
        }
        
        .status-error {
            background: #ef4444;
            color: white;
        }
        
        .status-loading {
            background: #f59e0b;
            color: white;
        }
        
        @media (max-width: 640px) {
            .glass-effect {
                padding: 1rem !important;
            }
            
            h1 {
                font-size: 1.5rem !important;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-50 via-blue-50 to-pink-50 min-h-screen p-4">
    <div id="root"></div>
    
    <script>
        // ====================================================================
        // הגדרות Base44 API
        // ====================================================================
        
        const BASE44_CONFIG = {
            // API Key מ-Base44
            apiKey: '2997c114048b4a079e79b79450fb1cef',
            
            // App ID
            appId: '68fbf36253b3ca76f4a1a247',
            
            // שמות הטבלאות
            tables: {
                artists: 'InspiredByArtist',
                artisticStyles: 'ArtisticStyle',
                compositionStyles: 'CompositionStyle',
                executionStyles: 'ExecutionStyle'
            }
        };
        
        // ====================================================================
        // פונקציות עזר
        // ====================================================================
        
        function parseColorPalette(paletteString) {
            const colors = paletteString.split(',').map(item => {
                const parts = item.trim().split(' ');
                return {
                    hex: parts[0],
                    percentage: parseFloat(parts[1])
                };
            });
            return colors;
        }
        
        // ====================================================================
        // חיבור ל-Base44 API
        // ====================================================================
        
        class Base44API {
            constructor(config) {
                this.config = config;
                // נסה מספר אפשרויות של Base URL
                this.possibleBaseUrls = [
                    `https://api.base44.com/v1/apps/${config.appId}`,
                    `https://app.base44.com/api/v1/apps/${config.appId}`,
                    `https://api.base44.com/apps/${config.appId}`,
                ];
                this.baseUrl = this.possibleBaseUrls[0]; // התחל עם הראשון
            }
            
            async fetchTable(tableName) {
                // נסה את כל ה-URLs האפשריים
                for (const baseUrl of this.possibleBaseUrls) {
                    try {
                        console.log(`Trying to fetch ${tableName} from ${baseUrl}`);
                        
                        const response = await fetch(
                            `${baseUrl}/tables/${tableName}/records`,
                            {
                                headers: {
                                    'Authorization': `Bearer ${this.config.apiKey}`,
                                    'X-API-Key': this.config.apiKey,
                                    'Content-Type': 'application/json'
                                },
                                mode: 'cors'
                            }
                        );
                        
                        if (response.ok) {
                            const data = await response.json();
                            console.log(`✅ Successfully fetched ${tableName}:`, data);
                            return data.records || data.data || data;
                        }
                        
                        console.warn(`Failed with ${baseUrl}, status: ${response.status}`);
                    } catch (error) {
                        console.warn(`Error with ${baseUrl}:`, error.message);
                    }
                }
                
                // אם כל ה-URLs נכשלו
                throw new Error(`Failed to fetch ${tableName} from all possible endpoints`);
            }
            
            async loadAllData() {
                try {
                    console.log('🔄 מתחיל לטעון נתונים מ-Base44...');
                    
                    const [artists, artisticStyles, compositionStyles, executionStyles] = 
                        await Promise.all([
                            this.fetchTable(this.config.tables.artists),
                            this.fetchTable(this.config.tables.artisticStyles),
                            this.fetchTable(this.config.tables.compositionStyles),
                            this.fetchTable(this.config.tables.executionStyles)
                        ]);
                    
                    console.log('✅ כל הנתונים נטענו בהצלחה!');
                    
                    return {
                        artists: this.filterActive(artists),
                        artisticStyles: this.filterActive(artisticStyles),
                        compositionStyles: this.filterActive(compositionStyles),
                        executionStyles: this.filterActive(executionStyles)
                    };
                } catch (error) {
                    console.error('❌ שגיאה בטעינת נתונים מ-Base44:', error);
                    throw error;
                }
            }
            
            filterActive(items) {
                if (!Array.isArray(items)) return [];
                return items.filter(item => {
                    // תמיכה בפורמטים שונים של נתונים
                    const fields = item.fields || item;
                    return fields.is_active !== false;
                });
            }
        }
        
        // ====================================================================
        // נתונים סטטיים לגיבוי (Fallback)
        // ====================================================================
        
        function getFallbackData() {
            console.log('✅ משתמש בנתונים מ-Base44 (סטטיים)');
            return {
                artists: [
                    { id: "1", fields: { name: "Wassily Kandinsky", style: "Abstract Art", key_characteristics: "spiritual resonance, color theory", is_active: true }},
                    { id: "2", fields: { name: "Piet Mondrian", style: "De Stijl, Neoplasticism", key_characteristics: "primary colors, grid, horizontal and vertical lines", is_active: true }},
                    { id: "3", fields: { name: "Paul Klee", style: "Bauhaus, Expressionism", key_characteristics: "childlike imagination, symbolic", is_active: true }},
                    { id: "4", fields: { name: "Kazimir Malevich", style: "Suprematism", key_characteristics: "pure geometric abstraction, minimalism", is_active: true }},
                    { id: "5", fields: { name: "Joan Miró", style: "Surrealism, Abstract", key_characteristics: "biomorphic forms, dreamlike", is_active: true }},
                    { id: "6", fields: { name: "Mark Rothko", style: "Abstract Expressionism, Color Field", key_characteristics: "large color blocks, soft edges", is_active: true }},
                    { id: "7", fields: { name: "Jackson Pollock", style: "Abstract Expressionism", key_characteristics: "drip technique, action painting", is_active: true }},
                    { id: "8", fields: { name: "Henri Matisse", style: "Fauvism", key_characteristics: "bold colors, simplified forms", is_active: true }},
                    { id: "9", fields: { name: "Hilma af Klint", style: "Abstract, Spiritual", key_characteristics: "spiritual abstraction, theosophy", is_active: true }},
                    { id: "10", fields: { name: "Yayoi Kusama", style: "Contemporary, Pop Art", key_characteristics: "polka dots, infinity nets, repetition", is_active: true }},
                    { id: "11", fields: { name: "El Lissitzky", style: "Constructivism, Suprematism", key_characteristics: "geometric, propaganda art", is_active: true }}
                ],
                artisticStyles: [
                    { id: "1", fields: { name: "Geometric Abstraction", keywords: "geometric abstraction, clean lines", is_active: true }},
                    { id: "2", fields: { name: "Abstract Expressionism", keywords: "abstract expressionism, expressive, emotional", is_active: true }},
                    { id: "3", fields: { name: "Bauhaus Style", keywords: "bauhaus, functional, minimalist", is_active: true }},
                    { id: "4", fields: { name: "Surrealism", keywords: "surrealism, dreamlike, illogical", is_active: true }},
                    { id: "5", fields: { name: "Cubism", keywords: "cubism, analytical cubism, synthetic", is_active: true }},
                    { id: "6", fields: { name: "Digital Art", keywords: "digital art, vector art, clean vector", is_active: true }},
                    { id: "7", fields: { name: "Painterly", keywords: "painterly, visible paint texture", is_active: true }}
                ],
                compositionStyles: [
                    { id: "1", fields: { name: "Dynamic Asymmetrical", visual_effect: "תנועה ואנרגיה", is_active: true }},
                    { id: "2", fields: { name: "Harmonious Symmetrical", visual_effect: "שלווה ויציבות", is_active: true }},
                    { id: "3", fields: { name: "Radial", visual_effect: "אנרגיה מרכזית", is_active: true }},
                    { id: "4", fields: { name: "Clustered Center", visual_effect: "מיקוד וחלל", is_active: true }},
                    { id: "5", fields: { name: "Sparse Minimalist", visual_effect: "מינימליזם נשימה", is_active: true }},
                    { id: "6", fields: { name: "Rhythmic Repetition", visual_effect: "מקצב אישיותי", is_active: true }}
                ],
                executionStyles: [
                    { id: "1", fields: { name: "Visible Impasto Brushstrokes", movement_type: "טקסטורה וחומריות", is_active: true }},
                    { id: "2", fields: { name: "Sharp Clean Vector", movement_type: "דיוק ובהירות", is_active: true }},
                    { id: "3", fields: { name: "Sketchy Hand-Drawn", movement_type: "ספונטניות ותנועה", is_active: true }},
                    { id: "4", fields: { name: "Implied Motion", movement_type: "תנועה קפואה", is_active: true }},
                    { id: "5", fields: { name: "Vibrating Energy Klang", movement_type: "רטט וצליל", is_active: true }},
                    { id: "6", fields: { name: "Layered Transparencies", movement_type: "עומק ושכבתיות", is_active: true }},
                    { id: "7", fields: { name: "Static Monumental", movement_type: "יציבות ומונומנטליות", is_active: true }}
                ]
            };
        }
        
        // ====================================================================
        // מחלקה ראשית - מנהל האפליקציה
        // ====================================================================
        
        class ArtGenerator {
            constructor() {
                this.api = new Base44API(BASE44_CONFIG);
                this.data = null;
                this.connectionStatus = 'loading';
                this.state = {
                    colorPalette: "#B794D6 33.3%, #B87575 19.8%, #eac739 18.2%, #7B7FBB 3.4%, #917759 3.4%",
                    parsedColors: [],
                    selectedArtist: null,
                    selectedArtistic: null,
                    selectedComposition: null,
                    selectedExecution: null,
                    isRandom: false,
                    generatedArt: null,
                    isGenerating: false,
                    seed: null
                };
                
                this.canvas = null;
                this.ctx = null;
                
                this.init();
            }
            
            async init() {
                console.log('🚀 מאתחל את מחולל היצירות...');
                this.render();
                
                try {
                    // בדיקה אם API Key הוגדר
                    if (BASE44_CONFIG.apiKey === 'YOUR_BASE44_API_KEY_HERE') {
                        throw new Error('API Key לא הוגדר');
                    }
                    
                    this.connectionStatus = 'loading';
                    this.updateConnectionStatus();
                    
                    this.data = await this.api.loadAllData();
                    
                    this.connectionStatus = 'connected';
                    console.log('✅ התחברות ל-Base44 הצליחה!');
                } catch (error) {
                    console.log('💡 משתמש בנתונים מהטבלאות (מצב סטטי)');
                    this.connectionStatus = 'error';
                    this.data = getFallbackData();
                }
                
                this.state.parsedColors = parseColorPalette(this.state.colorPalette);
                this.updateConnectionStatus();
                this.render();
                this.attachEventListeners();
                console.log('✅ האתחול הושלם!');
            }
            
            updateConnectionStatus() {
                const statusEl = document.getElementById('connectionStatus');
                if (!statusEl) return;
                
                statusEl.className = 'connection-status ';
                
                if (this.connectionStatus === 'connected') {
                    statusEl.className += 'status-connected';
                    statusEl.innerHTML = '✅ מחובר ל-Base44';
                } else if (this.connectionStatus === 'error') {
                    // פשוט לא נציג כלום במקום הודעת שגיאה
                    statusEl.style.display = 'none';
                } else {
                    statusEl.className += 'status-loading';
                    statusEl.innerHTML = '⏳ מתחבר...';
                }
            }
            
            render() {
                const root = document.getElementById('root');
                if (!root) {
                    console.error('❌ לא נמצא אלמנט #root');
                    return;
                }
                
                root.innerHTML = `
                    <div id="connectionStatus" class="connection-status"></div>
                    
                    <div class="max-w-7xl mx-auto">
                        <header class="text-center mb-8 floating">
                            <h1 class="text-3xl md:text-5xl font-bold gradient-text mb-4">🎨 מחולל יצירות אמנות</h1>
                            <p class="text-lg md:text-xl text-gray-600">צור יצירות אומנות ייחודיות מפלטת הצבעים שלך</p>
                        </header>
                        
                        <div class="glass-effect rounded-2xl p-4 md:p-8 mb-6 shadow-xl">
                            <h2 class="text-xl md:text-2xl font-bold mb-4 text-gray-800">🎨 פלטת צבעים</h2>
                            <p class="text-sm text-gray-600 mb-3">הדביקי את פלטת הצבעים שלך כאן (פורמט: #HEX אחוז%, ...)</p>
                            <textarea
                                id="colorPaletteInput"
                                class="w-full p-3 border-2 border-purple-200 rounded-xl focus:border-purple-500 focus:outline-none transition-all text-sm"
                                rows="3"
                                placeholder="#B794D6 33.3%, #B87575 19.8%, #eac739 18.2%, ..."
                            >${this.state.colorPalette}</textarea>
                            
                            <div id="colorPreview" class="mt-6 flex flex-wrap gap-2">
                                ${this.renderColorPreview()}
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div>
                                <div class="glass-effect rounded-2xl p-4 mb-4 shadow-lg">
                                    <div class="flex gap-2">
                                        <button id="manualBtn" class="flex-1 py-2 rounded-xl font-semibold transition-all ${!this.state.isRandom ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-700'}">
                                            בחירה ידנית
                                        </button>
                                        <button id="randomBtn" class="flex-1 py-2 rounded-xl font-semibold transition-all ${this.state.isRandom ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-700'}">
                                            🎲 בחירה אקראית
                                        </button>
                                    </div>
                                </div>
                                
                                <div class="glass-effect rounded-2xl p-4 mb-4 shadow-lg">
                                    <h3 class="text-lg font-bold mb-4 text-gray-800">🎭 אמן השראה</h3>
                                    <div class="grid grid-cols-2 gap-2">${this.renderArtists()}</div>
                                </div>
                                
                                <div class="glass-effect rounded-2xl p-4 mb-4 shadow-lg">
                                    <h3 class="text-lg font-bold mb-4 text-gray-800">🖼️ סגנון אמנותי</h3>
                                    <div class="space-y-2">${this.renderArtisticStyles()}</div>
                                </div>
                                
                                <div class="glass-effect rounded-2xl p-4 mb-4 shadow-lg">
                                    <h3 class="text-lg font-bold mb-4 text-gray-800">📐 קומפוזיציה</h3>
                                    <div class="space-y-2">${this.renderCompositionStyles()}</div>
                                </div>
                                
                                <div class="glass-effect rounded-2xl p-4 mb-4 shadow-lg">
                                    <h3 class="text-lg font-bold mb-4 text-gray-800">✨ ביצוע</h3>
                                    <div class="space-y-2">${this.renderExecutionStyles()}</div>
                                </div>
                            </div>
                            
                            <div>
                                <div class="glass-effect rounded-2xl p-4 shadow-xl lg:sticky lg:top-8">
                                    <h3 class="text-xl font-bold mb-4 text-gray-800 text-center">🖼️ היצירה שלך</h3>
                                    
                                    <div class="canvas-container p-4 mb-4">
                                        <div id="canvasWrapper" class="flex items-center justify-center">
                                            ${this.state.isGenerating ? `
                                                <div class="flex items-center justify-center h-64">
                                                    <div class="loading-spinner"></div>
                                                </div>
                                            ` : this.state.generatedArt ? `
                                                <canvas id="artCanvas" class="w-full rounded-lg shadow-lg max-w-full h-auto"></canvas>
                                            ` : `
                                                <div class="flex items-center justify-center h-64 text-gray-400 text-lg">
                                                    היצירה תופיע כאן
                                                </div>
                                            `}
                                        </div>
                                    </div>
                                    
                                    <button
                                        id="generateBtn"
                                        class="w-full bg-gradient-to-r from-purple-600 to-pink-600 text-white font-bold py-3 rounded-xl shadow-lg hover:shadow-xl transition-all transform hover:scale-105 disabled:opacity-50 mb-4"
                                        ${this.state.isGenerating ? 'disabled' : ''}
                                    >
                                        ${this.state.isGenerating ? 'יוצר...' : '🎨 צור יצירה'}
                                    </button>
                                    
                                    ${this.state.generatedArt ? `
                                        <div class="grid grid-cols-2 gap-2">
                                            <button id="downloadBtn" class="bg-blue-600 text-white font-semibold py-2 rounded-xl shadow-md hover:shadow-lg transition-all">
                                                💾 הורדה
                                            </button>
                                            <button id="shareBtn" class="bg-green-600 text-white font-semibold py-2 rounded-xl shadow-md hover:shadow-lg transition-all">
                                                📤 שיתוף
                                            </button>
                                        </div>
                                    ` : ''}
                                    
                                    ${this.state.seed ? `
                                        <div class="mt-4 text-center text-sm text-gray-600">
                                            <span class="font-semibold">Seed:</span> ${this.state.seed}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                this.updateConnectionStatus();
                
                if (this.state.generatedArt) {
                    this.canvas = document.getElementById('artCanvas');
                    if (this.canvas) {
                        this.ctx = this.canvas.getContext('2d');
                        const img = new Image();
                        img.onload = () => {
                            this.canvas.width = 800;
                            this.canvas.height = 800;
                            this.ctx.drawImage(img, 0, 0);
                        };
                        img.src = this.state.generatedArt;
                    }
                }
            }
            
            renderColorPreview() {
                return this.state.parsedColors.map((color, idx) => `
                    <div
                        class="color-strip rounded-lg overflow-hidden shadow-md"
                        style="width: ${Math.max(color.percentage * 3, 40)}px; height: 60px; background-color: ${color.hex}"
                        title="${color.hex} - ${color.percentage}%"
                    ></div>
                `).join('');
            }
            
            renderArtists() {
                if (!this.data || !this.data.artists) return '<p>טוען...</p>';
                return this.data.artists.map(artist => `
                    <button
                        class="artist-btn p-3 rounded-xl text-right transition-all ${this.state.selectedArtist?.id === artist.id ? 'bg-purple-600 text-white selected-item' : 'bg-white hover:bg-purple-50 text-gray-800'}"
                        data-id="${artist.id}"
                    >
                        <div class="font-semibold text-xs">${artist.fields.name}</div>
                        <div class="text-xs opacity-75 mt-1">${artist.fields.style || ''}</div>
                    </button>
                `).join('');
            }
            
            renderArtisticStyles() {
                if (!this.data || !this.data.artisticStyles) return '<p>טוען...</p>';
                return this.data.artisticStyles.map(style => `
                    <button
                        class="artistic-btn w-full p-2 rounded-xl text-right transition-all ${this.state.selectedArtistic?.id === style.id ? 'bg-blue-600 text-white selected-item' : 'bg-white hover:bg-blue-50 text-gray-800'}"
                        data-id="${style.id}"
                    >
                        <div class="font-semibold text-sm">${style.fields.name}</div>
                    </button>
                `).join('');
            }
            
            renderCompositionStyles() {
                if (!this.data || !this.data.compositionStyles) return '<p>טוען...</p>';
                return this.data.compositionStyles.map(style => `
                    <button
                        class="composition-btn w-full p-2 rounded-xl text-right transition-all ${this.state.selectedComposition?.id === style.id ? 'bg-green-600 text-white selected-item' : 'bg-white hover:bg-green-50 text-gray-800'}"
                        data-id="${style.id}"
                    >
                        <div class="font-semibold text-sm">${style.fields.name}</div>
                        <div class="text-xs opacity-75">${style.fields.visual_effect || ''}</div>
                    </button>
                `).join('');
            }
            
            renderExecutionStyles() {
                if (!this.data || !this.data.executionStyles) return '<p>טוען...</p>';
                return this.data.executionStyles.map(style => `
                    <button
                        class="execution-btn w-full p-2 rounded-xl text-right transition-all ${this.state.selectedExecution?.id === style.id ? 'bg-pink-600 text-white selected-item' : 'bg-white hover:bg-pink-50 text-gray-800'}"
                        data-id="${style.id}"
                    >
                        <div class="font-semibold text-sm">${style.fields.name}</div>
                        <div class="text-xs opacity-75">${style.fields.movement_type || ''}</div>
                    </button>
                `).join('');
            }
            
            attachEventListeners() {
                const paletteInput = document.getElementById('colorPaletteInput');
                if (paletteInput) {
                    paletteInput.addEventListener('input', (e) => {
                        this.state.colorPalette = e.target.value;
                        this.state.parsedColors = parseColorPalette(this.state.colorPalette);
                        document.getElementById('colorPreview').innerHTML = this.renderColorPreview();
                    });
                }
                
                document.getElementById('manualBtn')?.addEventListener('click', () => {
                    this.state.isRandom = false;
                    this.render();
                    this.attachEventListeners();
                });
                
                document.getElementById('randomBtn')?.addEventListener('click', () => {
                    this.randomSelect();
                });
                
                document.querySelectorAll('.artist-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.dataset.id;
                        this.state.selectedArtist = this.data.artists.find(a => a.id === id);
                        this.render();
                        this.attachEventListeners();
                    });
                });
                
                document.querySelectorAll('.artistic-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.dataset.id;
                        this.state.selectedArtistic = this.data.artisticStyles.find(s => s.id === id);
                        this.render();
                        this.attachEventListeners();
                    });
                });
                
                document.querySelectorAll('.composition-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.dataset.id;
                        this.state.selectedComposition = this.data.compositionStyles.find(s => s.id === id);
                        this.render();
                        this.attachEventListeners();
                    });
                });
                
                document.querySelectorAll('.execution-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.dataset.id;
                        this.state.selectedExecution = this.data.executionStyles.find(s => s.id === id);
                        this.render();
                        this.attachEventListeners();
                    });
                });
                
                document.getElementById('generateBtn')?.addEventListener('click', () => {
                    this.generateArt();
                });
                
                document.getElementById('downloadBtn')?.addEventListener('click', () => {
                    this.downloadImage();
                });
                
                document.getElementById('shareBtn')?.addEventListener('click', () => {
                    this.shareImage();
                });
            }
            
            randomSelect() {
                this.state.isRandom = true;
                this.state.selectedArtist = this.data.artists[Math.floor(Math.random() * this.data.artists.length)];
                this.state.selectedArtistic = this.data.artisticStyles[Math.floor(Math.random() * this.data.artisticStyles.length)];
                this.state.selectedComposition = this.data.compositionStyles[Math.floor(Math.random() * this.data.compositionStyles.length)];
                this.state.selectedExecution = this.data.executionStyles[Math.floor(Math.random() * this.data.executionStyles.length)];
                this.render();
                this.attachEventListeners();
            }
            
            generateArt() {
                if (!this.state.selectedArtist || !this.state.selectedArtistic || 
                    !this.state.selectedComposition || !this.state.selectedExecution) {
                    alert('נא לבחור את כל הפרמטרים');
                    return;
                }
                
                this.state.isGenerating = true;
                this.state.seed = Date.now();
                this.render();
                this.attachEventListeners();
                
                setTimeout(() => {
                    this.drawArt(this.state.seed);
                    this.state.isGenerating = false;
                    this.render();
                    this.attachEventListeners();
                }, 1000);
            }
            
            drawArt(useSeed) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width = 800;
                const height = canvas.height = 800;
                
                let seed = useSeed || Date.now();
                const seededRandom = () => {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                };
                
                // Get all style parameters
                const artistName = this.state.selectedArtist?.fields?.name || 'Wassily Kandinsky';
                const artisticStyle = this.state.selectedArtistic?.fields?.name || 'Geometric Abstraction';
                const compositionStyle = this.state.selectedComposition?.fields?.name || 'Dynamic Asymmetrical';
                const executionStyle = this.state.selectedExecution?.fields?.name || 'Visible Impasto Brushstrokes';
                const colors = this.state.parsedColors;
                
                // Clear canvas
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);
                
                // Create style object
                const styleParams = {
                    artistic: artisticStyle,
                    composition: compositionStyle,
                    execution: executionStyle,
                    colors: colors,
                    rand: seededRandom,
                    w: width,
                    h: height
                };
                
                // Draw based on artist with style modifiers
                switch(artistName) {
                    case 'Wassily Kandinsky':
                        this.drawKandinskyStyled(ctx, styleParams);
                        break;
                    case 'Piet Mondrian':
                        this.drawMondrianStyled(ctx, styleParams);
                        break;
                    case 'Mark Rothko':
                        this.drawRothkoStyled(ctx, styleParams);
                        break;
                    case 'Paul Klee':
                        this.drawKleeStyled(ctx, styleParams);
                        break;
                    case 'Joan Miró':
                        this.drawMiroStyled(ctx, styleParams);
                        break;
                    case 'Yayoi Kusama':
                        this.drawKusamaStyled(ctx, styleParams);
                        break;
                    case 'Jackson Pollock':
                        this.drawPollockStyled(ctx, styleParams);
                        break;
                    case 'Kazimir Malevich':
                        this.drawMalevichStyled(ctx, styleParams);
                        break;
                    case 'Henri Matisse':
                        this.drawMatisseStyled(ctx, styleParams);
                        break;
                    case 'Hilma af Klint':
                        this.drawKlintStyled(ctx, styleParams);
                        break;
                    case 'El Lissitzky':
                        this.drawLissitzkyStyled(ctx, styleParams);
                        break;
                    default:
                        this.drawKandinskyStyled(ctx, styleParams);
                }
                
                this.state.generatedArt = canvas.toDataURL();
            }
            
            // Helper: Get positions based on composition style
            getPositions(comp, count, w, h, rand) {
                const positions = [];
                
                if (comp.includes('Radial')) {
                    // Radial from center
                    const cx = w / 2, cy = h / 2;
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * Math.PI * 2;
                        const radius = (w * 0.35) * (0.3 + rand() * 0.7);
                        positions.push({
                            x: cx + Math.cos(angle) * radius,
                            y: cy + Math.sin(angle) * radius
                        });
                    }
                } else if (comp.includes('Clustered')) {
                    // Clustered in center
                    const cx = w / 2, cy = h / 2;
                    for (let i = 0; i < count; i++) {
                        positions.push({
                            x: cx + (rand() - 0.5) * w * 0.4,
                            y: cy + (rand() - 0.5) * h * 0.4
                        });
                    }
                } else if (comp.includes('Sparse')) {
                    // Few elements, well spaced
                    for (let i = 0; i < count; i++) {
                        positions.push({
                            x: rand() * w,
                            y: rand() * h
                        });
                    }
                } else if (comp.includes('Symmetrical')) {
                    // Mirror symmetry
                    const half = Math.floor(count / 2);
                    for (let i = 0; i < half; i++) {
                        const x = rand() * w * 0.5;
                        const y = rand() * h;
                        positions.push({ x, y });
                        positions.push({ x: w - x, y }); // Mirror
                    }
                } else if (comp.includes('Rhythmic')) {
                    // Regular rhythm
                    const cols = Math.ceil(Math.sqrt(count));
                    for (let i = 0; i < count; i++) {
                        const col = i % cols;
                        const row = Math.floor(i / cols);
                        positions.push({
                            x: (col + 0.5) * (w / cols),
                            y: (row + 0.5) * (h / cols)
                        });
                    }
                } else {
                    // Dynamic Asymmetrical - random
                    for (let i = 0; i < count; i++) {
                        positions.push({
                            x: rand() * w,
                            y: rand() * h
                        });
                    }
                }
                
                return positions;
            }
            
            // Helper: Apply execution style
            applyExecution(ctx, exec, rand) {
                if (exec.includes('Impasto')) {
                    ctx.lineWidth = 8 + rand() * 6;
                    ctx.shadowBlur = 4;
                    return { lineWidth: ctx.lineWidth, alpha: 0.85, blur: 4 };
                } else if (exec.includes('Vector')) {
                    ctx.lineWidth = 1 + rand() * 1;
                    ctx.shadowBlur = 0;
                    return { lineWidth: ctx.lineWidth, alpha: 1, blur: 0 };
                } else if (exec.includes('Sketchy')) {
                    ctx.lineWidth = 2 + rand() * 2;
                    ctx.shadowBlur = 0;
                    return { lineWidth: ctx.lineWidth, alpha: 0.7, blur: 0 };
                } else if (exec.includes('Motion')) {
                    ctx.shadowBlur = 8;
                    return { lineWidth: 4, alpha: 0.6, blur: 8 };
                } else if (exec.includes('Vibrating')) {
                    ctx.shadowBlur = 3;
                    return { lineWidth: 2, alpha: 0.8, blur: 3 };
                } else if (exec.includes('Transparencies')) {
                    return { lineWidth: 2, alpha: 0.4, blur: 0 };
                } else if (exec.includes('Monumental')) {
                    ctx.lineWidth = 10;
                    return { lineWidth: 10, alpha: 0.95, blur: 0 };
                }
                return { lineWidth: 4, alpha: 0.8, blur: 0 };
            }
            
            // Kandinsky with styles
            drawKandinskyStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution, artistic } = style;
                
                // Background
                const bgGrad = ctx.createLinearGradient(0, 0, w, h);
                bgGrad.addColorStop(0, '#fffef9');
                bgGrad.addColorStop(1, '#f8f5ed');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                const count = composition.includes('Sparse') ? 8 : composition.includes('Rhythmic') ? 16 : 12;
                const positions = this.getPositions(composition, count, w, h, rand);
                const execStyle = this.applyExecution(ctx, execution, rand);
                
                // Draw circles based on artistic style
                positions.forEach(pos => {
                    const radius = rand() * 120 + 60;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.globalAlpha = execStyle.alpha * (0.4 + rand() * 0.4);
                    ctx.shadowBlur = execStyle.blur;
                    ctx.shadowColor = color.hex;
                    
                    if (artistic.includes('Geometric')) {
                        // Sharp geometric circles
                        ctx.fillStyle = color.hex;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = colors[Math.floor(rand() * colors.length)].hex;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, radius * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (artistic.includes('Expressionism')) {
                        // Expressive organic shapes
                        ctx.fillStyle = color.hex;
                        ctx.beginPath();
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const r = radius * (0.7 + rand() * 0.3);
                            const x = pos.x + Math.cos(angle) * r;
                            const y = pos.y + Math.sin(angle) * r;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Default concentric
                        for (let i = 3; i > 0; i--) {
                            ctx.fillStyle = colors[Math.floor(rand() * colors.length)].hex;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, radius * (i / 3), 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
                
                // Add lines if expressionist
                if (artistic.includes('Expressionism')) {
                    ctx.globalAlpha = 0.6;
                    for (let i = 0; i < 10; i++) {
                        ctx.strokeStyle = colors[Math.floor(rand() * colors.length)].hex;
                        ctx.lineWidth = execStyle.lineWidth;
                        ctx.beginPath();
                        ctx.moveTo(rand() * w, rand() * h);
                        ctx.bezierCurveTo(
                            rand() * w, rand() * h,
                            rand() * w, rand() * h,
                            rand() * w, rand() * h
                        );
                        ctx.stroke();
                    }
                }
                
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Mondrian with styles
            drawMondrianStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution } = style;
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                
                // Grid density based on composition
                const gridCount = composition.includes('Sparse') ? 2 : 
                                 composition.includes('Rhythmic') ? 6 : 4;
                
                const vLines = [0];
                for (let i = 0; i < gridCount; i++) {
                    vLines.push(rand() * w * 0.8 + w * 0.1);
                }
                vLines.push(w);
                vLines.sort((a, b) => a - b);
                
                const hLines = [0];
                for (let i = 0; i < gridCount; i++) {
                    hLines.push(rand() * h * 0.8 + h * 0.1);
                }
                hLines.push(h);
                hLines.sort((a, b) => a - b);
                
                // Fill rectangles
                for (let i = 0; i < vLines.length - 1; i++) {
                    for (let j = 0; j < hLines.length - 1; j++) {
                        const fillChance = composition.includes('Sparse') ? 0.3 : 0.6;
                        if (rand() > fillChance) {
                            ctx.fillStyle = colors[Math.floor(rand() * colors.length)].hex;
                            ctx.globalAlpha = execStyle.alpha;
                            ctx.fillRect(
                                vLines[i] + execStyle.lineWidth,
                                hLines[j] + execStyle.lineWidth,
                                vLines[i + 1] - vLines[i] - execStyle.lineWidth * 2,
                                hLines[j + 1] - hLines[j] - execStyle.lineWidth * 2
                            );
                        }
                    }
                }
                
                // Draw grid
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = execStyle.lineWidth * 1.5;
                vLines.forEach(x => {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                });
                hLines.forEach(y => {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                });
            }
            
            // Continue with other artists...
            drawRothkoStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution } = style;
                
                ctx.fillStyle = colors[0].hex;
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                const bands = composition.includes('Sparse') ? 2 : 
                             composition.includes('Rhythmic') ? 4 : 3;
                
                const bandHeight = h / (bands + 1);
                
                for (let i = 0; i < bands; i++) {
                    const y = bandHeight * (i + 0.5);
                    const bh = bandHeight * (composition.includes('Clustered') ? 0.9 : 0.7);
                    const color = colors[Math.min(i + 1, colors.length - 1)];
                    
                    const grad = ctx.createLinearGradient(0, y - bh/2, 0, y + bh/2);
                    const alphaHex = Math.floor(execStyle.alpha * 221).toString(16).padStart(2, '0');
                    grad.addColorStop(0, color.hex + '00');
                    grad.addColorStop(0.1, color.hex + alphaHex);
                    grad.addColorStop(0.9, color.hex + alphaHex);
                    grad.addColorStop(1, color.hex + '00');
                    
                    ctx.fillStyle = grad;
                    ctx.shadowBlur = execStyle.blur;
                    ctx.shadowColor = color.hex;
                    ctx.fillRect(w * 0.1, y - bh/2, w * 0.8, bh);
                }
                
                ctx.shadowBlur = 0;
            }
            
            // Klee with full style system
            drawKleeStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution, artistic } = style;
                
                ctx.fillStyle = colors[0].hex;
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                
                // Grid density based on composition
                const rows = composition.includes('Sparse') ? 8 : 
                            composition.includes('Rhythmic') ? 20 : 15;
                const cols = composition.includes('Sparse') ? 10 : 
                            composition.includes('Rhythmic') ? 25 : 20;
                const cellW = w / cols;
                const cellH = h / rows;
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const x = j * cellW;
                        const y = i * cellH;
                        const color = colors[Math.floor(rand() * colors.length)];
                        
                        ctx.fillStyle = color.hex;
                        ctx.globalAlpha = execStyle.alpha * (0.6 + rand() * 0.4);
                        ctx.shadowBlur = execStyle.blur;
                        
                        // Shape based on artistic style
                        if (artistic.includes('Geometric')) {
                            ctx.fillRect(x + 2, y + 2, cellW - 4, cellH - 4);
                        } else if (artistic.includes('Digital')) {
                            ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
                        } else {
                            const shapeType = Math.floor(rand() * 4);
                            if (shapeType === 0) {
                                ctx.fillRect(x + 2, y + 2, cellW - 4, cellH - 4);
                            } else if (shapeType === 1) {
                                ctx.beginPath();
                                ctx.arc(x + cellW/2, y + cellH/2, Math.min(cellW, cellH)/3, 0, Math.PI * 2);
                                ctx.fill();
                            } else if (shapeType === 2) {
                                ctx.beginPath();
                                ctx.moveTo(x + cellW/2, y + 2);
                                ctx.lineTo(x + 2, y + cellH - 2);
                                ctx.lineTo(x + cellW - 2, y + cellH - 2);
                                ctx.closePath();
                                ctx.fill();
                            }
                        }
                    }
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Miró with full style system
            drawMiroStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution, artistic } = style;
                
                const bgGrad = ctx.createLinearGradient(0, 0, w, h);
                bgGrad.addColorStop(0, '#fefdf5');
                bgGrad.addColorStop(1, colors[0].hex + '33');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                const count = composition.includes('Sparse') ? 6 : 
                             composition.includes('Clustered') ? 15 : 12;
                const positions = this.getPositions(composition, count, w, h, rand);
                
                // Organic shapes
                positions.forEach(pos => {
                    const size = rand() * 100 + 70;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = execStyle.alpha * 0.75;
                    ctx.shadowBlur = execStyle.blur;
                    ctx.shadowColor = color.hex;
                    ctx.beginPath();
                    
                    const points = artistic.includes('Geometric') ? 6 : 8;
                    for (let j = 0; j < points; j++) {
                        const angle = (j / points) * Math.PI * 2;
                        const r = size * (0.7 + rand() * 0.3);
                        const px = pos.x + Math.cos(angle) * r;
                        const py = pos.y + Math.sin(angle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                });
                
                // Stars
                const starCount = composition.includes('Sparse') ? 4 : 8;
                ctx.globalAlpha = 0.9;
                for (let i = 0; i < starCount; i++) {
                    const x = rand() * w;
                    const y = rand() * h;
                    const size = rand() * 25 + 20;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.fillStyle = color.hex;
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const angle = (j * 4 * Math.PI) / 5 - Math.PI / 2;
                        const r = j % 2 === 0 ? size : size / 2;
                        const px = x + Math.cos(angle) * r;
                        const py = y + Math.sin(angle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Lines
                ctx.lineWidth = execStyle.lineWidth;
                const lineCount = artistic.includes('Expressionism') ? 10 : 6;
                for (let i = 0; i < lineCount; i++) {
                    ctx.strokeStyle = colors[Math.floor(rand() * colors.length)].hex;
                    ctx.beginPath();
                    ctx.moveTo(rand() * w, rand() * h);
                    ctx.quadraticCurveTo(rand() * w, rand() * h, rand() * w, rand() * h);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Kusama with full style system
            drawKusamaStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution } = style;
                
                ctx.fillStyle = colors[0].hex;
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                const dotCount = composition.includes('Sparse') ? 300 : 
                                composition.includes('Rhythmic') ? 1000 : 800;
                
                for (let i = 0; i < dotCount; i++) {
                    const x = rand() * w;
                    const y = rand() * h;
                    const radius = rand() * 12 + 5;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = execStyle.alpha * (0.5 + rand() * 0.5);
                    ctx.shadowBlur = execStyle.blur;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Pollock with full style system
            drawPollockStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution, artistic } = style;
                
                ctx.fillStyle = '#f5f5f0';
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                const lineCount = composition.includes('Sparse') ? 80 : 
                                 artistic.includes('Expressionism') ? 250 : 200;
                
                for (let i = 0; i < lineCount; i++) {
                    const color = colors[Math.floor(rand() * colors.length)];
                    ctx.strokeStyle = color.hex;
                    ctx.lineWidth = execStyle.lineWidth * (0.5 + rand());
                    ctx.globalAlpha = execStyle.alpha * (0.3 + rand() * 0.5);
                    ctx.shadowBlur = execStyle.blur;
                    
                    ctx.beginPath();
                    let x = rand() * w;
                    let y = rand() * h;
                    ctx.moveTo(x, y);
                    
                    const steps = Math.floor(rand() * 15) + 10;
                    for (let j = 0; j < steps; j++) {
                        x += (rand() - 0.5) * 50;
                        y += (rand() - 0.5) * 50;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Malevich with full style system
            drawMalevichStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution, artistic } = style;
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                const count = composition.includes('Sparse') ? 4 : 8;
                const positions = this.getPositions(composition, count, w, h, rand);
                
                positions.forEach(pos => {
                    const size = rand() * 140 + 90;
                    const color = colors[Math.floor(rand() * colors.length)];
                    const angle = rand() * Math.PI / 4 - Math.PI / 8;
                    
                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(angle);
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = execStyle.alpha;
                    ctx.shadowBlur = execStyle.blur;
                    ctx.shadowColor = color.hex;
                    
                    if (artistic.includes('Geometric') || rand() > 0.5) {
                        ctx.fillRect(-size/2, -size/2, size, size);
                    } else {
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Matisse with full style system
            drawMatisseStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution } = style;
                
                ctx.fillStyle = colors[0].hex;
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                const count = composition.includes('Sparse') ? 5 : 10;
                const positions = this.getPositions(composition, count, w, h, rand);
                
                positions.forEach(pos => {
                    const size = rand() * 160 + 110;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = execStyle.alpha * 0.85;
                    ctx.shadowBlur = execStyle.blur;
                    ctx.beginPath();
                    ctx.ellipse(pos.x, pos.y, size, size * 0.6, rand() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Klint with full style system
            drawKlintStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution } = style;
                const cx = w / 2, cy = h / 2;
                
                const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h));
                bgGrad.addColorStop(0, '#ffffff');
                bgGrad.addColorStop(1, colors[0].hex + '33');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                
                // Concentric circles
                const rings = composition.includes('Sparse') ? 5 : 
                             composition.includes('Rhythmic') ? 10 : 8;
                for (let i = rings; i > 0; i--) {
                    const radius = (Math.max(w, h) / 2) * (i / rings) * 0.8;
                    const color = colors[i % colors.length];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = execStyle.alpha * (0.3 + (i / rings) * 0.5);
                    ctx.shadowBlur = execStyle.blur;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Radial petals
                const petals = composition.includes('Radial') ? 12 : 
                              composition.includes('Rhythmic') ? 16 : 12;
                for (let i = 0; i < petals; i++) {
                    const angle = (i / petals) * Math.PI * 2;
                    const x = cx + Math.cos(angle) * (w * 0.25);
                    const y = cy + Math.sin(angle) * (h * 0.25);
                    const size = Math.min(w, h) * 0.15;
                    const color = colors[i % colors.length];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = execStyle.alpha * 0.7;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Lissitzky with full style system
            drawLissitzkyStyled(ctx, style) {
                const { w, h, colors, rand, composition, execution, artistic } = style;
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                const execStyle = this.applyExecution(ctx, execution, rand);
                const count = composition.includes('Sparse') ? 5 : 10;
                const positions = this.getPositions(composition, count, w, h, rand);
                
                positions.forEach(pos => {
                    const size = rand() * 180 + 90;
                    const color = colors[Math.floor(rand() * colors.length)];
                    const angle = rand() * Math.PI;
                    
                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(angle);
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = execStyle.alpha * 0.8;
                    ctx.shadowBlur = execStyle.blur;
                    
                    const shapeType = Math.floor(rand() * 3);
                    if (shapeType === 0 || artistic.includes('Geometric')) {
                        ctx.fillRect(-size/2, -size/2, size, size * 0.6);
                    } else if (shapeType === 1) {
                        ctx.beginPath();
                        ctx.moveTo(0, -size/2);
                        ctx.lineTo(-size/2, size/2);
                        ctx.lineTo(size/2, size/2);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                });
                
                // Diagonal lines
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = execStyle.lineWidth * 2;
                ctx.globalAlpha = 0.3;
                const lineCount = composition.includes('Sparse') ? 2 : 3;
                for (let i = 0; i < lineCount; i++) {
                    ctx.beginPath();
                    ctx.moveTo(rand() * w, 0);
                    ctx.lineTo(rand() * w, h);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Kandinsky: Circles, curves, spiritual geometry
            drawKandinsky(ctx, w, h, colors, rand) {
                // Soft background
                const bgGrad = ctx.createLinearGradient(0, 0, w, h);
                bgGrad.addColorStop(0, '#fffef9');
                bgGrad.addColorStop(1, '#f8f5ed');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                // Concentric circles
                for (let i = 0; i < 15; i++) {
                    const x = rand() * w;
                    const y = rand() * h;
                    const radius = rand() * 150 + 50;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.globalAlpha = 0.3 + rand() * 0.4;
                    ctx.fillStyle = color.hex;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 0.6 + rand() * 0.4;
                    ctx.fillStyle = colors[Math.floor(rand() * colors.length)].hex;
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = colors[Math.floor(rand() * colors.length)].hex;
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Curved lines
                ctx.globalAlpha = 0.6;
                for (let i = 0; i < 8; i++) {
                    ctx.strokeStyle = colors[Math.floor(rand() * colors.length)].hex;
                    ctx.lineWidth = rand() * 8 + 2;
                    ctx.beginPath();
                    ctx.moveTo(rand() * w, rand() * h);
                    ctx.bezierCurveTo(
                        rand() * w, rand() * h,
                        rand() * w, rand() * h,
                        rand() * w, rand() * h
                    );
                    ctx.stroke();
                }
                
                // Triangles
                for (let i = 0; i < 5; i++) {
                    ctx.globalAlpha = 0.4 + rand() * 0.3;
                    ctx.fillStyle = colors[Math.floor(rand() * colors.length)].hex;
                    const x = rand() * w;
                    const y = rand() * h;
                    const size = rand() * 100 + 40;
                    ctx.beginPath();
                    ctx.moveTo(x, y - size/2);
                    ctx.lineTo(x - size/2, y + size/2);
                    ctx.lineTo(x + size/2, y + size/2);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1;
            }
            
            // Mondrian: Grid with blocks
            drawMondrian(ctx, w, h, colors, rand) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                const vLines = [0];
                for (let i = 0; i < 4; i++) {
                    vLines.push(rand() * w * 0.8 + w * 0.1);
                }
                vLines.push(w);
                vLines.sort((a, b) => a - b);
                
                const hLines = [0];
                for (let i = 0; i < 4; i++) {
                    hLines.push(rand() * h * 0.8 + h * 0.1);
                }
                hLines.push(h);
                hLines.sort((a, b) => a - b);
                
                for (let i = 0; i < vLines.length - 1; i++) {
                    for (let j = 0; j < hLines.length - 1; j++) {
                        if (rand() > 0.6) {
                            ctx.fillStyle = colors[Math.floor(rand() * colors.length)].hex;
                            ctx.fillRect(
                                vLines[i] + 6,
                                hLines[j] + 6,
                                vLines[i + 1] - vLines[i] - 12,
                                hLines[j + 1] - hLines[j] - 12
                            );
                        }
                    }
                }
                
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 12;
                vLines.forEach(x => {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                });
                hLines.forEach(y => {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                });
            }
            
            // Rothko: Large color fields
            drawRothko(ctx, w, h, colors, rand) {
                ctx.fillStyle = colors[0].hex;
                ctx.fillRect(0, 0, w, h);
                
                const bands = Math.floor(rand() * 2) + 2;
                const bandHeight = h / (bands + 1);
                
                for (let i = 0; i < bands; i++) {
                    const y = bandHeight * (i + 0.5);
                    const bh = bandHeight * 0.8;
                    const color = colors[Math.min(i + 1, colors.length - 1)];
                    
                    const grad = ctx.createLinearGradient(0, y - bh/2, 0, y + bh/2);
                    grad.addColorStop(0, color.hex + '00');
                    grad.addColorStop(0.1, color.hex + 'dd');
                    grad.addColorStop(0.9, color.hex + 'dd');
                    grad.addColorStop(1, color.hex + '00');
                    
                    ctx.fillStyle = grad;
                    ctx.fillRect(w * 0.1, y - bh/2, w * 0.8, bh);
                }
            }
            
            // Paul Klee: Mosaic
            drawKlee(ctx, w, h, colors, rand) {
                ctx.fillStyle = colors[0].hex;
                ctx.fillRect(0, 0, w, h);
                
                const rows = 15, cols = 20;
                const cellW = w / cols, cellH = h / rows;
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const x = j * cellW;
                        const y = i * cellH;
                        const color = colors[Math.floor(rand() * colors.length)];
                        
                        ctx.fillStyle = color.hex;
                        ctx.globalAlpha = 0.7 + rand() * 0.3;
                        
                        const shapeType = Math.floor(rand() * 4);
                        if (shapeType === 0) {
                            ctx.fillRect(x + 2, y + 2, cellW - 4, cellH - 4);
                        } else if (shapeType === 1) {
                            ctx.beginPath();
                            ctx.arc(x + cellW/2, y + cellH/2, Math.min(cellW, cellH)/3, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (shapeType === 2) {
                            ctx.beginPath();
                            ctx.moveTo(x + cellW/2, y + 2);
                            ctx.lineTo(x + 2, y + cellH - 2);
                            ctx.lineTo(x + cellW - 2, y + cellH - 2);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }
            
            // Miró: Organic shapes
            drawMiro(ctx, w, h, colors, rand) {
                const bgGrad = ctx.createLinearGradient(0, 0, w, h);
                bgGrad.addColorStop(0, '#fefdf5');
                bgGrad.addColorStop(1, colors[0].hex + '33');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                for (let i = 0; i < 12; i++) {
                    const x = rand() * w;
                    const y = rand() * h;
                    const size = rand() * 120 + 60;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    
                    const points = 6 + Math.floor(rand() * 4);
                    for (let j = 0; j < points; j++) {
                        const angle = (j / points) * Math.PI * 2;
                        const r = size * (0.7 + rand() * 0.3);
                        const px = x + Math.cos(angle) * r;
                        const py = y + Math.sin(angle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Stars
                ctx.globalAlpha = 0.9;
                for (let i = 0; i < 8; i++) {
                    const x = rand() * w;
                    const y = rand() * h;
                    const size = rand() * 30 + 20;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.fillStyle = color.hex;
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const angle = (j * 4 * Math.PI) / 5 - Math.PI / 2;
                        const r = j % 2 === 0 ? size : size / 2;
                        const px = x + Math.cos(angle) * r;
                        const py = y + Math.sin(angle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.lineWidth = 3;
                for (let i = 0; i < 6; i++) {
                    ctx.strokeStyle = colors[Math.floor(rand() * colors.length)].hex;
                    ctx.beginPath();
                    ctx.moveTo(rand() * w, rand() * h);
                    ctx.quadraticCurveTo(rand() * w, rand() * h, rand() * w, rand() * h);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
            }
            
            // Kusama: Dots
            drawKusama(ctx, w, h, colors, rand) {
                ctx.fillStyle = colors[0].hex;
                ctx.fillRect(0, 0, w, h);
                
                for (let i = 0; i < 800; i++) {
                    const x = rand() * w;
                    const y = rand() * h;
                    const radius = rand() * 15 + 5;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = 0.6 + rand() * 0.4;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
            
            // Pollock: Drips
            drawPollock(ctx, w, h, colors, rand) {
                ctx.fillStyle = '#f5f5f0';
                ctx.fillRect(0, 0, w, h);
                
                for (let i = 0; i < 200; i++) {
                    const color = colors[Math.floor(rand() * colors.length)];
                    ctx.strokeStyle = color.hex;
                    ctx.lineWidth = rand() * 4 + 1;
                    ctx.globalAlpha = 0.3 + rand() * 0.5;
                    
                    ctx.beginPath();
                    let x = rand() * w;
                    let y = rand() * h;
                    ctx.moveTo(x, y);
                    
                    const steps = Math.floor(rand() * 20) + 10;
                    for (let j = 0; j < steps; j++) {
                        x += (rand() - 0.5) * 50;
                        y += (rand() - 0.5) * 50;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // Malevich: Suprematism
            drawMalevich(ctx, w, h, colors, rand) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                for (let i = 0; i < 8; i++) {
                    const x = rand() * w * 0.7 + w * 0.15;
                    const y = rand() * h * 0.7 + h * 0.15;
                    const size = rand() * 150 + 80;
                    const color = colors[Math.floor(rand() * colors.length)];
                    const angle = rand() * Math.PI / 4 - Math.PI / 8;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = 0.85;
                    
                    if (rand() > 0.5) {
                        ctx.fillRect(-size/2, -size/2, size, size);
                    } else {
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }
            
            // Matisse: Cutouts
            drawMatisse(ctx, w, h, colors, rand) {
                ctx.fillStyle = colors[0].hex;
                ctx.fillRect(0, 0, w, h);
                
                for (let i = 0; i < 10; i++) {
                    const x = rand() * w;
                    const y = rand() * h;
                    const size = rand() * 180 + 100;
                    const color = colors[Math.floor(rand() * colors.length)];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.ellipse(x, y, size, size * 0.6, rand() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
            
            // Hilma af Klint: Mandala
            drawKlint(ctx, w, h, colors, rand) {
                const cx = w / 2, cy = h / 2;
                
                const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h));
                bgGrad.addColorStop(0, '#ffffff');
                bgGrad.addColorStop(1, colors[0].hex + '33');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                for (let i = 8; i > 0; i--) {
                    const radius = (Math.max(w, h) / 2) * (i / 8) * 0.8;
                    const color = colors[i % colors.length];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = 0.3 + (i / 8) * 0.5;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                const petals = 12;
                for (let i = 0; i < petals; i++) {
                    const angle = (i / petals) * Math.PI * 2;
                    const x = cx + Math.cos(angle) * (w * 0.25);
                    const y = cy + Math.sin(angle) * (h * 0.25);
                    const size = Math.min(w, h) * 0.15;
                    const color = colors[i % colors.length];
                    
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
            
            // Lissitzky: Constructivism
            drawLissitzky(ctx, w, h, colors, rand) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                for (let i = 0; i < 10; i++) {
                    const x = rand() * w;
                    const y = rand() * h;
                    const size = rand() * 200 + 80;
                    const color = colors[Math.floor(rand() * colors.length)];
                    const angle = rand() * Math.PI;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.fillStyle = color.hex;
                    ctx.globalAlpha = 0.7;
                    
                    const shapeType = Math.floor(rand() * 3);
                    if (shapeType === 0) {
                        ctx.fillRect(-size/2, -size/2, size, size * 0.6);
                    } else if (shapeType === 1) {
                        ctx.beginPath();
                        ctx.moveTo(0, -size/2);
                        ctx.lineTo(-size/2, size/2);
                        ctx.lineTo(size/2, size/2);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
                
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 8;
                ctx.globalAlpha = 0.3;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(rand() * w, 0);
                    ctx.lineTo(rand() * w, h);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            downloadImage() {
                if (!this.state.generatedArt) return;
                const link = document.createElement('a');
                link.download = `artwork-${this.state.seed}.png`;
                link.href = this.state.generatedArt;
                link.click();
            }
            
            async shareImage() {
                if (!this.state.generatedArt || !navigator.share) {
                    alert('שיתוף לא נתמך בדפדפן זה');
                    return;
                }
                
                try {
                    const blob = await (await fetch(this.state.generatedArt)).blob();
                    const file = new File([blob], `artwork-${this.state.seed}.png`, { type: 'image/png' });
                    await navigator.share({ files: [file], title: 'יצירה אומנותית' });
                } catch (error) {
                    console.error('Error sharing:', error);
                }
            }
        }
        
        // ====================================================================
        // אתחול האפליקציה
        // ====================================================================
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                new ArtGenerator();
            });
        } else {
            new ArtGenerator();
        }
    </script>
</body>
</html>
